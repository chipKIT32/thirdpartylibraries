//*******************************************************************************//*	//*	PicasoVGA Arduino drivers//*		The PicassoVGA shield is built use 4D labs Picaso VGA module//*	//*	(C) by Mark Sproul//*	This code is open source like the rest of the arduino source code//*//*******************************************************************************//*	<MLS> is Mark Sproul msproul@jove.rutgers.edu//*			http://coewww.rutgers.edu/~msproul///*******************************************************************************//*	Detailed edit history//*******************************************************************************//*	Dec 26,	2009	<MLS> Ordered Picaso board from Sparkfun.com//*	Dec 26,	2009	<MLS> Started on Picaso Arduino drivers//*	Dec 31,	2009	<MLS> Mostly done//*	Jan  2,	2010	<MLS> Picaso_DisplayImage now working//*	Jan 28,	2010	<MLS> Started on UnivGraphicsLib//*	Jan 30,	2010	<MLS> Added GrahicsHW_SetPixelRGB//*	Feb  6,	2010	<MLS> Added Picaso_DrawTextButton//*******************************************************************************#include	<string.h>#include	<stdio.h>#include	<stdlib.h>#if defined(__AVR__)	#include	<avr/pgmspace.h>#endif#include	"HardwareSerial.h"#include	"UnivGraphicsHW_Defs.h"#include	"UnivGraphicsLib.h"#include	"UnivGraphicsHardware.h"	//*	this is the routines that the implementer provides#ifdef _GRAPHICS_HW_PICASO_VGA_#define		kPicasoResetPin	7//*******************************************************************************//*	Picaso letter commands//*******************************************************************************/*General Command Set Serial 4DGL (A) Add User Bitmapped Character  (a) Set Viewing area(B) Set Background Colour(b) Place Text button(C) Draw Circle(c) Block copy and Paste (bitmap copy)(D) Display User Bitmapped Character              (E) Erase Screen(e) Draw ellipse(F) Font Size(G) Draw TrianGle(g) Draw Polygon(I) Display Image              (L) Draw Line(O) Opaque or Transparent Text     (P) Put Pixel(p) Set pen Size(R) Read Pixel(r) Draw rectangle(S) Place String of Text (unformatted/bitmapped)(s) Place string of Text (formatted)(T) Place Text Character (formatted)(t) Place text Character (unformatted/bitmapped)(V) Version/Device Info Request  (v) vsync Lock              (Y) DisplaY Control functions *///*******************************************************************************//*	the commented out lines are not implemented yet or are not needed//*******************************************************************************//#define	kPicasoCMD_AddBitmapChar			'A'//#define	kPicasoCMD_SetViewinArea			'a'#define	kPicasoCMD_SetBackGroundColor		'B'#define	kPicasoCMD_PlaceTextButton			'b'//#define	kPicasoCMD_DrawCirle				'C'//#define	kPicasoCMD_BlockCopyPaste			'c'//#define	kPicasoCMD_DispUsrBitmapChar		'D'#define	kPicasoCMD_EraseScreen				'E'#define	kPicasoCMD_DrawEllipse				'e'//#define	kPicasoCMD_FontSize					'F'#define	kPicasoCMD_DrawTrianGle				'G'//#define	kPicasoCMD_DrawPolygon				'g'#define	kPicasoCMD_DisplayImage				'I'#define	kPicasoCMD_DrawLine					'L'#define	kPicasoCMD_OpaqueTransparentTxt		'O'#define	kPicasoCMD_PutPixel					'P'#define	kPicasoCMD_SetPenSize				'p'//#define	kPicasoCMD_ReadPixel				'R'#define	kPicasoCMD_DrawRectangle			'r'#define	kPicasoCMD_DrawTextUnformatted		'S'//#define	kPicasoCMD_DrawTextFormatted		's'//#define	kPicasoCMD_DrawCharFormatted		'T'#define	kPicasoCMD_DrawCharUnformatted		't'//#define	kPicasoCMD_VersionRequest			'V'		//*	not implimented in uVGA//#define	kPicasoCMD_VsyncLock				'v'#define	kPicasoCMD_DisplaVideoRamSettings	'Y'#define	kPicasoCMD_AutoBaud					'U'			//*	this is not a normal command, only used on startup//*	thePenSize is 0 for solid fill//*	thePenSize is 1 for wire frame#define	kPenSize_SolidFill	0#define	kPenSize_WireFrame	1//*******************************************************************************//*	Globals needed for drawing//*	these are private and should not be referenced by the userstatic	unsigned char	gPicasoForeColor;static	unsigned char	gPicasoBackColor;static	unsigned char	gPicasoCurrPenSize;static	unsigned long	gErrorTimeOutCount;//+static	int				gPicasoResetCount;//+static	int				gErrorNakCount;//static	unsigned char	gPicasoCurrentCmd;//*******************************************************************************static void		Picaso_SendNewCommand(unsigned char theCmdChar);static void		Picaso_SendByte(unsigned char theByte);static void		Picaso_SendWord(unsigned short theWord);static char		Picaso_WaitForAck(void);static void		Picaso_SetTextMode(char textMode);static void		Picaso_DrawRect(RECT *theRect, unsigned char thePenSize, unsigned char the8BitColor);static void		Picaso_DrawEllipse(RECT *theRect, unsigned char thePenSize, unsigned char the8BitColor);static void		Picaso_DrawTriangle(int x1, int y1, int x2, int y2, int x3, int y3, unsigned char thePenSize, unsigned char the8BitColor);static boolean	Picaso_CheckRectForOnScreen(RECT *theRect);static void		Picaso_DrawEllipseFromCenter(short xCenter, short yCenter, short xRadius, short yRadius, unsigned char thePenSize, unsigned char the8BitColor);#pragma mark -#pragma mark Required Graphics Hardware Routines//*******************************************************************************//*	returns TRUE if succesfullboolean	GrahicsHW_CheckIfPresent(void){	return(true);}#define	kResetDetlay	300//*******************************************************************************boolean	GrahicsHW_Init(void){char	picasoResolution;char	ackChar;boolean	successFlag;	successFlag			=	false;	gPicasoBackColor	=	0;	gPicasoForeColor	=	0xc0;	gPicasoCurrPenSize	=	100;	//*	set to something invalid so it forces the first time	gWidth				=	310;	//*	fake it for now	gHeight				=	210;//+	gErrorNakCount		=	0;	gErrorTimeOutCount	=	0;//+	gPicasoResetCount	=	0;	//*	configure the reset pin to the Picaso	pinMode(kPicasoResetPin, OUTPUT);	digitalWrite(kPicasoResetPin, HIGH);	//*	enable the serial port#ifdef _ARDUINO_MEGA_//	Serial3.begin(115200);	//*	works well	Serial3.begin(230400);	//*	tested 1/3/09, works//	Serial3.begin(345600);	//*	does not work//	Serial3.begin(460800);	//*	does not work#elif defined(_USE_SOFT_SERIAL_)	gSoftSerialToPicaso.begin(9600);#else	Serial.begin(115200);#endif	delay(250);	//*	we want to leave it high for a bit	//*	put the picaso into reset	digitalWrite(kPicasoResetPin, LOW);	delay(kResetDetlay);	digitalWrite(kPicasoResetPin, HIGH);	delay(kResetDetlay);	Picaso_SendNewCommand(kPicasoCMD_AutoBaud);	//*	auto baud char for Picaso	Picaso_WaitForAck();	picasoResolution	=	1;				//*	0=QVGA, 1=VGA, 2=SVGA	Picaso_SendNewCommand(kPicasoCMD_DisplaVideoRamSettings);	Picaso_SendByte(03);					//*	Change resolution	Picaso_SendByte(picasoResolution);		//*	0=QVGA, 1=VGA, 2=SVGA	delay(2500);							//*	this takes longer than most, wait some extra time here	ackChar	=	Picaso_WaitForAck();	if (ackChar != 0)	{		successFlag			=	true;	}	switch(picasoResolution)	{		case 0:			gWidth		=	310;	//*	fake it for now			gHeight		=	210;			break;		case 1:			gWidth		=	620;	//*	fake it for now			gHeight		=	420;			break;//		case 2://			gWidth		=	800;	//*	fake it for now//			gHeight		=	560;//			break;	}	if (picasoResolution != 0)	{		//*	we have to wait for the reset and re-autobaud		delay(1000);		Picaso_SendNewCommand(kPicasoCMD_AutoBaud);	//*	auto baud char for Picaso		Picaso_WaitForAck();	}//	delay(1000);	Picaso_SetTextMode(1);	return(successFlag);}//*******************************************************************************void	GrahicsHW_Reset(void){//+	gPicasoResetCount++;		//*	configure the reset pin to the Picaso	pinMode(kPicasoResetPin, OUTPUT);	digitalWrite(kPicasoResetPin, HIGH);	delay(500);	//*	we want to leave it high for a bit	//*	put the picaso into reset	digitalWrite(kPicasoResetPin, LOW);	delay(500);	digitalWrite(kPicasoResetPin, HIGH);	delay(500);	Picaso_SendNewCommand(kPicasoCMD_AutoBaud);	//*	auto baud char for Picaso	delay(1000);	gWidth		=	310;	//*	fake it for now	gHeight		=	210;}//*******************************************************************************int	GrahicsHW_GetWidth(void){	return(gWidth);}//*******************************************************************************int	GrahicsHW_GetHeight(void){	return(gHeight);}//*******************************************************************************void	GrahicsHW_EraseScreen(void){	Picaso_SendNewCommand(kPicasoCMD_EraseScreen);	delay(20);	//*	we know this takes a while	Picaso_WaitForAck();}//*******************************************************************************void	GrahicsHW_SetPixel(int xLoc, int yLoc, unsigned char theColorByte){	Picaso_SendNewCommand(kPicasoCMD_PutPixel);	Picaso_SendWord(xLoc);	Picaso_SendWord(yLoc);	Picaso_SendByte(theColorByte);	Picaso_WaitForAck();}#pragma mark -#pragma mark Optional Graphics Hardware Routines//*******************************************************************************void	GrahicsHW_DrawLine(int x1, int y1, int x2, int y2, unsigned char the8BitColor){	//*	bounds checking	if ((x1 < 0) && (x2 < 0))	{		return;	}	if ((y1 < 0) && (y2 < 0))	{		return;	}	if ((x1 >= gWidth) && (x2 >= gWidth))	{		return;	}	if ((y1 >= gHeight) && (y2 >= gHeight))	{		return;	}	Picaso_SendNewCommand(kPicasoCMD_DrawLine);	Picaso_SendWord(x1);	Picaso_SendWord(y1);	Picaso_SendWord(x2);	Picaso_SendWord(y2);	Picaso_SendByte(the8BitColor);	Picaso_WaitForAck();}//*******************************************************************************void	GrahicsHW_Set8bitForeColor(unsigned char the8bitColor){	gPicasoForeColor	=	the8bitColor;}//*******************************************************************************void	GrahicsHW_Set8bitBackColor(unsigned char the8bitColor){	gPicasoBackColor	=	the8bitColor;	Picaso_SendNewCommand(kPicasoCMD_SetBackGroundColor);	Picaso_SendByte(gPicasoBackColor);	Picaso_WaitForAck();}//*******************************************************************************void	GrahicsHW_DrawRect(RECT *theRect, unsigned char the8BitColor){	Picaso_DrawRect(theRect, kPenSize_WireFrame, the8BitColor);}//*******************************************************************************void	GrahicsHW_FillRect(RECT *theRect, unsigned char the8BitColor){	Picaso_DrawRect(theRect, kPenSize_SolidFill, the8BitColor);}//*******************************************************************************void	GrahicsHW_DrawEllipseFromCenter(	short			xCenter,											short			yCenter,											short			xRadius,											short			yRadius,											unsigned char	thePenSize,											unsigned char	the8BitColor){	//*	do we need to change the pen size	if (thePenSize != gPicasoCurrPenSize)	{	char	ackChar;			//*	thePenSize is 0 for solid fill		//*	thePenSize is 1 for wire frame		Picaso_SendNewCommand(kPicasoCMD_SetPenSize);		Picaso_SendByte(thePenSize);		ackChar	=	Picaso_WaitForAck();		if (ackChar == 0x06)		{			gPicasoCurrPenSize	=	thePenSize;		}	}	Picaso_SendNewCommand(kPicasoCMD_DrawEllipse);	Picaso_SendWord(xCenter);	Picaso_SendWord(yCenter);	Picaso_SendWord(xRadius);	Picaso_SendWord(yRadius);	Picaso_SendByte(the8BitColor);	Picaso_WaitForAck();	}//*******************************************************************************void	GrahicsHW_DrawEllipse(RECT *theRect, unsigned char the8BitColor){short	myCenterX, myCenterY;short	myRadiusX, myRadiusY;boolean	rectIsOnScrene;	//*	bounds checking	rectIsOnScrene	=	Picaso_CheckRectForOnScreen(theRect);	if (rectIsOnScrene)	{		myCenterX	=	(theRect->left + theRect->right) / 2;		myCenterY	=	(theRect->top + theRect->bottom) / 2;		myRadiusX	=	(theRect->right - theRect->left) / 2;		myRadiusY	=	(theRect->bottom - theRect->top) / 2;		Picaso_DrawEllipseFromCenter(myCenterX, myCenterY, myRadiusX, myRadiusY, kPenSize_WireFrame, the8BitColor);	}}//*******************************************************************************void	GrahicsHW_FillEllipse(RECT *theRect, unsigned char the8BitColor){short	myCenterX, myCenterY;short	myRadiusX, myRadiusY;boolean	rectIsOnScrene;	//*	bounds checking	rectIsOnScrene	=	Picaso_CheckRectForOnScreen(theRect);	if (rectIsOnScrene)	{		myCenterX	=	(theRect->left + theRect->right) / 2;		myCenterY	=	(theRect->top + theRect->bottom) / 2;		myRadiusX	=	(theRect->right - theRect->left) / 2;		myRadiusY	=	(theRect->bottom - theRect->top) / 2;		Picaso_DrawEllipseFromCenter(myCenterX, myCenterY, myRadiusX, myRadiusY, kPenSize_SolidFill, the8BitColor);	}}//*******************************************************************************void	GrahicsHW_DrawTriangle(int x1, int y1, int x2, int y2, int x3, int y3, unsigned char the8BitColor){	Picaso_DrawTriangle(x1, y1, x2, y2, x3, y3, kPenSize_WireFrame, the8BitColor);}//*******************************************************************************void	GrahicsHW_FillTriangle(int x1, int y1, int x2, int y2, int x3, int y3, unsigned char the8BitColor){	Picaso_DrawTriangle(x1, y1, x2, y2, x3, y3, kPenSize_SolidFill, the8BitColor);}//*******************************************************************************void	GrahicsHW_DrawText(int xLoc, int yLoc, char *textString){int	ii;	Picaso_SendNewCommand(kPicasoCMD_DrawTextUnformatted);	Picaso_SendWord(xLoc);	Picaso_SendWord(yLoc);	Picaso_SendByte(2);	Picaso_SendByte(gPicasoForeColor);	Picaso_SendByte(1);	Picaso_SendByte(1);	ii	=	0;	while(textString[ii] != 0)	{		Picaso_SendByte(textString[ii]);		ii++;	}	//*	requires a null to terminate the string	Picaso_SendByte(0);	Picaso_WaitForAck();}//*******************************************************************************void	GrahicsHW_DrawChar(int xLoc, int yLoc, char theChar){	Picaso_SendNewCommand(kPicasoCMD_DrawCharUnformatted);	Picaso_SendByte(theChar);	Picaso_SendWord(xLoc);	Picaso_SendWord(yLoc);	Picaso_SendByte(gPicasoForeColor);	Picaso_SendByte(1);	Picaso_SendByte(1);	Picaso_WaitForAck();}//*******************************************************************************//*	this needs to be modifed to include color etcvoid	GrahicsHW_DrawButtonWtext(	int				xLoc,									int				yLoc,									unsigned char	buttonState,									unsigned char	buttonColor,									unsigned char	textColor,									char			*buttonText){short	ii;unsigned char	textWidth	=	3;unsigned char	textHeight	=	3;	if (buttonText[0] != 0)	{		Picaso_SetTextMode(0);		Picaso_SendNewCommand(kPicasoCMD_PlaceTextButton);		Picaso_SendByte(buttonState);		Picaso_SendWord(xLoc);		Picaso_SendWord(yLoc);		Picaso_SendByte(buttonColor);		Picaso_SendByte(2);		Picaso_SendByte(textColor);		Picaso_SendByte(textWidth);		Picaso_SendByte(textHeight);		ii	=	0;		while (buttonText[ii] != 0)		{			Picaso_SendByte(buttonText[ii]);			ii++;		}		Picaso_SendByte(0);	}	Picaso_WaitForAck();	Picaso_SetTextMode(1);}#pragma mark -#pragma mark Private Picaso routines, not for external use//*******************************************************************************//*	these routines are intended for internal use only which is why they are all//*	declared static. Please use either the QuickDraw or Procesing interface//*******************************************************************************//*******************************************************************************static void	Picaso_SendByte(unsigned char theByte){#ifdef _ENABLE_CMD_DEBUG_char	outputBuff[16];	sprintf(outputBuff, "%02X ", theByte);	Serial.print(outputBuff);#endif#ifdef _ARDUINO_MEGA_	Serial3.write(theByte);#elif defined(_USE_SOFT_SERIAL_)	gSoftSerialToPicaso.print(theByte);#else	Serial.write(theByte);#endif//	delay(4);//	delay(2);//	delayMicroseconds(1500);}//*******************************************************************************//*	check for char availablestatic boolean	Picaso_CheckAvailable(void){boolean	isAvailable;#ifdef _ARDUINO_MEGA_	isAvailable	=	Serial3.available();#elif defined(_USE_SOFT_SERIAL_)#else	isAvailable	=	Serial.available();#endif	return(isAvailable);}//*******************************************************************************static char	Picaso_ReadChar(void){char	charFromPicaso;#ifdef _ARDUINO_MEGA_	charFromPicaso	=	Serial3.read();#elif defined(_USE_SOFT_SERIAL_)#else	charFromPicaso	=	Serial.read();#endif	return(charFromPicaso);}//*******************************************************************************static void	Picaso_SendNewCommand(unsigned char theCmdChar){int				charFromPicaso;	//*	check to make sure the buffer from the Picaso chip is empty	while (Picaso_CheckAvailable())	{		charFromPicaso	=	Picaso_ReadChar();	}#ifdef _PISCASO_SHOW_PERFORMANCE_	gPicasoCommandStartTime	=	millis();	gPicasoCommandCount++;#endif	Picaso_SendByte(theCmdChar);//+	gPicasoCurrentCmd	=	theCmdChar;}//*******************************************************************************static void	Picaso_SendWord(unsigned short theWord){	Picaso_SendByte(theWord >> 8);	Picaso_SendByte(theWord & 0x0ff);}//*******************************************************************************static char	Picaso_WaitForAck(void){int				charFromPicaso;boolean			waitForAck;unsigned long	startMiliseconds;unsigned long	curMiliseconds;	charFromPicaso	=	0x00;#ifdef _ENABLE_CMD_DEBUG_	Serial.print("\r\n");#endif	startMiliseconds	=	millis();	waitForAck	=	true;	while (waitForAck || Picaso_CheckAvailable())	{		if (Picaso_CheckAvailable())		{			charFromPicaso	=	Picaso_ReadChar();			if (charFromPicaso == 0x06)			{				waitForAck			=	false;				gErrorTimeOutCount	=	0;			#ifdef _PISCASO_SHOW_PERFORMANCE_				gPicasoDrawTime	+=	(millis() - gPicasoCommandStartTime);			#endif			}			else if (charFromPicaso == 0x15)			{				if (waitForAck)				{					//*	only record the FIRST nak//+					gErrorNakCount++;				}				waitForAck	=	false;			}		}		curMiliseconds	=	millis();		if ((curMiliseconds - startMiliseconds) > 2500)		{			gErrorTimeOutCount++;			waitForAck	=	false;			if (gErrorTimeOutCount > 10)			{				GrahicsHW_Reset();				gErrorTimeOutCount	=	0;			}		}	}	return(charFromPicaso);}#pragma mark -#pragma mark Picaso drawing routines//*******************************************************************************static void	Picaso_DrawRect(RECT *theRect, unsigned char thePenSize, unsigned char the8BitColor){boolean	rectIsOnScrene;	//*	bounds checking	rectIsOnScrene	=	Picaso_CheckRectForOnScreen(theRect);	if (rectIsOnScrene)	{		//*	do we need to change the pen size		if (thePenSize != gPicasoCurrPenSize)		{		char	ackChar;					//*	thePenSize is 0 for solid fill			//*	thePenSize is 1 for wire frame			Picaso_SendNewCommand(kPicasoCMD_SetPenSize);			Picaso_SendByte(thePenSize);			ackChar	=	Picaso_WaitForAck();			if (ackChar == 0x06)			{				gPicasoCurrPenSize	=	thePenSize;			}		}		Picaso_SendNewCommand(kPicasoCMD_DrawRectangle);		Picaso_SendWord(theRect->left);		Picaso_SendWord(theRect->top);		Picaso_SendWord(theRect->right);		Picaso_SendWord(theRect->bottom);		Picaso_SendByte(the8BitColor);		Picaso_WaitForAck();	}	}//*******************************************************************************void	Picaso_DrawEllipseFromCenter(	short			xCenter,										short			yCenter,										short			xRadius,										short			yRadius,										unsigned char	thePenSize,										unsigned char	the8BitColor){	//*	do we need to change the pen size	if (thePenSize != gPicasoCurrPenSize)	{	char	ackChar;			//*	thePenSize is 0 for solid fill		//*	thePenSize is 1 for wire frame		Picaso_SendNewCommand(kPicasoCMD_SetPenSize);		Picaso_SendByte(thePenSize);		ackChar	=	Picaso_WaitForAck();		if (ackChar == 0x06)		{			gPicasoCurrPenSize	=	thePenSize;		}	}	Picaso_SendNewCommand(kPicasoCMD_DrawEllipse);	Picaso_SendWord(xCenter);	Picaso_SendWord(yCenter);	Picaso_SendWord(xRadius);	Picaso_SendWord(yRadius);	Picaso_SendByte(the8BitColor);	Picaso_WaitForAck();	}//*******************************************************************************static void	Picaso_DrawEllipse(RECT *theRect, unsigned char thePenSize, unsigned char the8BitColor){short	myCenterX, myCenterY;short	myRadiusX, myRadiusY;boolean	rectIsOnScrene;	//*	bounds checking	rectIsOnScrene	=	Picaso_CheckRectForOnScreen(theRect);	if (rectIsOnScrene)	{		myCenterX	=	(theRect->left + theRect->right) / 2;		myCenterY	=	(theRect->top + theRect->bottom) / 2;		myRadiusX	=	(theRect->right - theRect->left) / 2;		myRadiusY	=	(theRect->bottom - theRect->top) / 2;		Picaso_DrawEllipseFromCenter(myCenterX, myCenterY, myRadiusX, myRadiusY, thePenSize, the8BitColor);	}}//*******************************************************************************void	Picaso_DrawTriangle(int x1, int y1, int x2, int y2, int x3, int y3,								unsigned char thePenSize, unsigned char the8BitColor){	//*	do we need to change the pen size	if (thePenSize != gPicasoCurrPenSize)	{	char	ackChar;			//*	thePenSize is 0 for solid fill		//*	thePenSize is 1 for wire frame		Picaso_SendNewCommand(kPicasoCMD_SetPenSize);		Picaso_SendByte(thePenSize);		ackChar	=	Picaso_WaitForAck();		if (ackChar == 0x06)		{			gPicasoCurrPenSize	=	thePenSize;		}	}	Picaso_SendNewCommand(kPicasoCMD_DrawTrianGle);	Picaso_SendWord(x1);	Picaso_SendWord(y1);	Picaso_SendWord(x2);	Picaso_SendWord(y2);	Picaso_SendWord(x3);	Picaso_SendWord(y3);	Picaso_SendByte(the8BitColor);	Picaso_WaitForAck();}//*******************************************************************************static	boolean	Picaso_CheckRectForOnScreen(RECT *theRect){boolean	rectIsOnScrene;	rectIsOnScrene	=	true;	//*	bounds checking	if ((theRect->left >= gWidth) || ((theRect->right <= 0)))	{		rectIsOnScrene	=	false;	}	else if ((theRect->top >= gHeight) || ((theRect->bottom <= 0)))	{		rectIsOnScrene	=	false;	}		return(rectIsOnScrene);}//*******************************************************************************static void	Picaso_SetTextMode(char textMode){	Picaso_SendNewCommand(kPicasoCMD_OpaqueTransparentTxt);	Picaso_SendByte(textMode);	Picaso_WaitForAck();}#ifdef __MWERKS__	//*****************************************************************************	//*	This is for <MLS> to be able to use Codewarrior for editing	//*	this is so the code compiles under Metrowerks CodeWarrior,	//*	it doesnt run or link, just compiles	//*****************************************************************************	#undef		pgm_read_byte_near	#define		pgm_read_byte_near(x)	(char)x#endif//*******************************************************************************void	Picaso_DisplayImage(	short			xLoc,								short			yLoc,								short			imgWidth,								short			imgHeight,								unsigned char	pixelsPerByte,								unsigned char	*imageData){//long			pixelCount;long			ii;short			bb;long			byteCount;unsigned char	theByte;unsigned char	thePixelColor;	Picaso_SendNewCommand(kPicasoCMD_DisplayImage);	Picaso_SendWord(xLoc);	Picaso_SendWord(yLoc);	Picaso_SendWord(imgWidth);	Picaso_SendWord(imgHeight);	Picaso_SendByte(8);		//*	Note: µVGA-PICASO-MD1 only supports 256 colours.	switch(pixelsPerByte)	{	//	case 1:	//		pixelCount	=	imgWidth * imgHeight;	//		for (ii=0; ii<pixelCount; ii++)	//		{	//			theByte	=	pgm_read_byte_near(pic + ii);	//			Picaso_SendByte(theByte);	//		}	//		break;				case 8:			byteCount	=	(1L * imgWidth * imgHeight) / 8;			for (ii=0; ii<byteCount; ii++)			{				theByte	=	pgm_read_byte_near(imageData + ii);				for (bb=0; bb<8; bb++)				{					if (theByte & 0x80)					{						thePixelColor	=	gPicasoForeColor;					}					else					{						//*	set to background color						thePixelColor	=	gPicasoBackColor;					}					Picaso_SendByte(thePixelColor);					theByte	=	theByte << 1;				}			}			break;	}	Picaso_WaitForAck();}#endif	//	_GRAPHICS_HW_PICASO_VGA_