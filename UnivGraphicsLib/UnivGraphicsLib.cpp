//*******************************************************************************//*	//*	UnivGraphicsLib//*	(C) 2010 by Mark Sproul (KB2ICI)//*			http://www.avr-developers.com///*		//*	This code is open source like the rest of the arduino source code//*	Please send any comments or changes to me  msproul _at_ skychariot.com//*//*		UnivGraphicsLib is an attempt to unify the various graphics cards//*		available for the Arduino platform.//*	//*		The intent of this library is to abstract the graphics routines from//*		the hardware routines, In that end, it will require only a few routines//*		to get a new graphics card up and running.//*	//*		This library is an abstraction layer, seperating the graphics from the hardware//*		Every ARduino graphics drivers I have worked with have a lot of interaction//*		between the graphics and the hardware. Also none of them are compatible.//*	//*		A sperate file needs to be created with the actual harware routines//*		By implementing the routines below, a new graphics screen should be able//*		to be up in running in very short order. If the graphics device has//*		more capabilties (such as the Picaso), then it can be enhanced to use them//*		as well.//*	//*******************************************************************************//*	Graphic devices I am working with and that this code has been tested on//*			Picaso uVGA from sparkfun						8 bit color//*			GLCD from Adafruit (ks0108 LCD driver)			1 bit B/W (pinout B)//*			LCD-0022 Graphic LCD Module 128x64 NKC			1 bit B/W (pinout A)//*			GLCD 160x128 Huge sku: LCD-08799 from sparkfun	1 bit//*//*	If you want drivers written for another card, let me know and I will do my best//*//*******************************************************************************//*	In order to get a graphics card up and running, a MINIMUM of the following//*	routines must be implemented//*//*//*		boolean	GrahicsHW_CheckIfPresent(void);	//*	returns TRUE if succesfull//*		boolean	GrahicsHW_Init(void);			//*	returns TRUE if succesfull//*		int		GrahicsHW_GetWidth(void);		//*	returns screen width (X direction)//*		int		GrahicsHW_GetHeight(void);		//*	returns screen height (Y direction)//*		void	GrahicsHW_SetPixelRGB(short xLoc, short yLoc, RGBColor *theColor);//*			or//*		void	GrahicsHW_SetPixel(short xLoc, short yLoc, unsigned char theColor);//*//*//*//*	UnivGraphicsHW_Defs.h must contain one of these for the specifc graphics card//*		#define	_UGL_HARDWARE_FULL_COLOR_	(both 16 bit and 24 bit color)//*		#define	_UGL_HARDWARE_8BIT_//*		#define	_UGL_HARDWARE_1BIT_//*//*******************************************************************************//*	Copyright stuff//*//*		This library is distributed in the hope that it will be useful,//*		but WITHOUT ANY WARRANTY; without even the implied warranty of//*		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.//*//*		Some of this code is derived from code by  by inthebitz @ antipastohw.blogspot.com //*		and liquidware.com//*//*******************************************************************************//*	<MLS> Programming style//*	I have been programming computers for over 30 years. I have worked for some//*	major corporations doing programming and have worked on some of the same//*	programs for over 10 years. This experiance has developed into fairly strict//*	coding rules and style. I promise you that if you adopt these rules your//*	code will be easier to read and easier to maintin.//*	as with any rules, sometimes someof them have to be broken to keep compatibility//*	//*			Never use 1 letter variable names, use LONG names,//*			{ and } always go on their own line//*			Never put 2 lines of code on the same line//*			Use TAB instead of multiple spaces//*			A comment line of "****"s above the start of each routine//*			Leave a space before and after each operator "a + b"  not "a+b"//*			Routine names should start with a CAPITAL letter//*			Variable names should always start with lower case,//*			Global variables should start with a lower case "g" followed by an UPPER case char//*			Constants (#define )  should start with a lower case "k" followed by an UPPER case char//*			UnderLine "_" is an ok char to use in variable names, routine names, and constants//*			Changes should include comments with your initials//*			Macros should have some comments explaining what they do and why//*******************************************************************************//*	<MLS> is Mark Sproul msproul _at_ skychariot.com//*			http://www.avr-developers.com///*******************************************************************************//*	Detailed edit history//*******************************************************************************//*	Jan 28,	2010	<MLS> Started on UnivGraphicsLib//*	Jan 28,	2010	<MLS> Picso uVGA board working under UnivGraphicsLib//*	Jan 29,	2010	<MLS> GLCD from Adafruit working under UnivGraphicsLib//*	Feb  3,	2010	<MLS> Adding Hershey fonts//*	Feb  6,	2010	<MLS> Added GrahicsHW_DrawButtonWtext (mainly for use with Picaso uVGA)//*	Feb  7,	2010	<MLS> Inverse (White on Black) now working for 1 bit graphics cards//*	Feb  8,	2010	<MLS> Copied arc and bezier from touchslide code (stuff I wrote for Liquidware)//*	Feb  8,	2010	<MLS> Ordered Graphic LCD 160x128 Huge sku: LCD-08799 from sparkfun, uses T6963C//*	Feb  8,	2010	<MLS> Started on support for T6963C//*	Jun 18,	2011	<MLS> Started on UGL again, this time with pic32 support in mind//*	Jun 19,	2011	<MLS> Added GrahicsHW_SetPixelRGB16bit//*******************************************************************************#include	<string.h>#include	<stdio.h>#include	<stdlib.h>#if defined(__AVR__)	#include	<avr/pgmspace.h>	#include	<avr/io.h>#endif#include	<inttypes.h>#include	<math.h>#include	"wiring.h"#include	<plib.h>//*	this ensures that this whole thing is disabled if the cpu does not have at least ports B and D#if defined(PORTB) && defined(PORTC) && defined(PORTD)	#define	_ENABLE_UGL_#endif#if defined(__PIC32MX__)	#define	_ENABLE_UGL_#endif#if defined(_ENABLE_UGL_)#include	"UnivGraphicsHW_Defs.h"#include	"UnivGraphicsLib.h"#include	"UnivGraphicsHardware.h"	//*	this is the routines that the implementer provides#define	_DEBUG_VIA_SERIAL_#pragma mark -#pragma mark Global variables//*******************************************************************************//*	Processing Global variables accessable to the user	short	gWidth;			//*	current screen width = processing "width"	short	gHeight;		//*	current screen height = processing "height"#ifdef _ENABLE_PROCESSING_ROUTINES_	SCREEN	screen;	uint8_t	gStrokeEnable;	uint8_t	gFillEnable;	uint8_t	gStrokeWeightVal;#endif//*******************************************************************************//*	Globals needed for drawing//*	these are private and should not be referenced by the user	static	RGBColor		gRGB_ForeColor;	static	RGBColor		gRGB_BackColor;	static	unsigned char	g8bitForeColor;	static	unsigned char	g8bitBackColor;#ifdef _ENABLE_QUICKDRAW_ROUTINES_	static	short			gCurrentLocationX;	static	short			gCurrentLocationY;#endif//*******************************************************************************//*******************************************************************************#pragma mark -#pragma mark Hardware routines pulled in here//*******************************************************************************#ifdef _GRAPHICS_HW_GLCD_T6963C_	#include	"Hardware_GLCDt6963c.cxx"#endif//*******************************************************************************#ifdef _GRAPHICS_HW_KS0108_	#include	"Hardware_ks0108.cxx"#endif//*******************************************************************************#ifdef _GRAPHICS_HW_PICASO_VGA_	#include	"Hardware_Picaso.cxx"#endif//*******************************************************************************#ifdef _GRAPHICS_HW_MikromediaPic32_	#define	_UGL_HARDWARE_FULL_COLOR_	#include	"Hardware_MikroElektronika.cxx"#endif//*******************************************************************************#ifdef _GRAPHICS_HW_NOIKA128_	#define	_UGL_HARDWARE_FULL_COLOR_	#include	"Hardware_Nokia128.cxx"#endif//*******************************************************************************#ifdef _GRAPHICS_HW_WIDE_TFT_	#define	_UGL_HARDWARE_FULL_COLOR_	#include	"Hardware_WideTFT.cxx"#endif#pragma mark -#pragma mark Misc general purpose Routines//*******************************************************************************boolean		UnivGraphicsLib_Init(void){boolean	initOK;#if defined(_UGL_HARDWARE_1BIT_)	#ifdef _MONOCHROME_BLACK_ON_WHITE_		g8bitForeColor	=	kCOLOR_Black;	#else		g8bitForeColor	=	kCOLOR_White;	#endif#endif	initOK	=	GrahicsHW_Init();#ifdef _ENABLE_PROCESSING_ROUTINES_	screen.width		=	GetScreenWidth();	screen.height		=	GetScreenHeight();	gStrokeEnable		=	true;	gFillEnable			=	true;	gStrokeWeightVal	=	1;#endif	gRGB_ForeColor.red		=	255;	gRGB_ForeColor.green	=	255;	gRGB_ForeColor.blue		=	255;	gRGB_BackColor.red		=	0;	gRGB_BackColor.green	=	0;	gRGB_BackColor.blue		=	0;	return(initOK);}//*******************************************************************************void	UnivGraphicsLib_GetCurrentBoard(char *currentBoardName){	strcpy(currentBoardName, "Board not defined");#ifdef _GRAPHICS_HW_KS0108_	strcpy(currentBoardName, "KS0108");#endif//*******************************************************************************#ifdef _GRAPHICS_HW_PICASO_VGA_	strcpy(currentBoardName, "Picaso VGA");#endif//*******************************************************************************#ifdef _GRAPHICS_HW_MikromediaPic32_	strcpy(currentBoardName, "MikroMedia (Microchip graphics)");#endif//*******************************************************************************#ifdef _GRAPHICS_HW_NOIKA128_	strcpy(currentBoardName, "Nokia 128x128");#endif//*******************************************************************************#ifdef _GRAPHICS_HW_WIDE_TFT_	strcpy(currentBoardName, "WIDE TFT");#endif}//*******************************************************************************short		GetScreenWidth(void){short	myWidth;	myWidth	=	GrahicsHW_GetWidth();	return(myWidth);}//*******************************************************************************short		GetScreenHeight(void){short	myHeight;	myHeight	=	GrahicsHW_GetHeight();	return(myHeight);}//*******************************************************************************unsigned char	Get8bitColorFromRGBcolor(RGBColor *theColor){unsigned char	eightBitRGBcolor;	//*	this format is	BBGGGRRR	//*	it is the format that the Picaso chip uses	eightBitRGBcolor	=	(theColor->blue & 0xC0);			//*	blue is left 2 bits	eightBitRGBcolor	|=	((theColor->green & 0xE0) >> 2);	//*	green is middle 3 bits	eightBitRGBcolor	|=	((theColor->red & 0xE0) >> 5);		//*	red is right 3 bits	return(eightBitRGBcolor);}//#if defined(_UGL_HARDWARE_8BIT_) || defined(_UGL_HARDWARE_1BIT_)//*******************************************************************************void	Set8bitForeColor(unsigned char the8bitColor){#ifdef _UGL_HARDWARE_8BIT_	g8bitForeColor	=	the8bitColor;	GrahicsHW_Set8bitForeColor(g8bitForeColor);#endif#ifdef _UGL_HARDWARE_1BIT_	//*	in 1 bit mode, foreground is ALWAYS one color	#ifdef _MONOCHROME_BLACK_ON_WHITE_		g8bitForeColor	=	kCOLOR_Black;	#else		g8bitForeColor	=	kCOLOR_White;	#endif#endif}//*******************************************************************************void	Set8bitBackColor(unsigned char the8bitColor){#ifdef _UGL_HARDWARE_8BIT_	g8bitBackColor	=	the8bitColor;#endif#ifdef _UGL_HARDWARE_1BIT_	//*	in 1 bit mode, Background is ALWAYS one color	#ifdef _MONOCHROME_BLACK_ON_WHITE_		g8bitBackColor	=	kCOLOR_White;	#else		g8bitBackColor	=	kCOLOR_Black;	#endif#endif}//#endif#pragma mark -#pragma mark Processing Routines#ifdef _ENABLE_PROCESSING_ROUTINES_//*******************************************************************************void	erasescreen(void){	GrahicsHW_EraseScreen();}//*******************************************************************************void	point(short xLoc, short yLoc){#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_SetPixelRGB(xLoc, yLoc, &gRGB_ForeColor);#elif defined(_UGL_HARDWARE_8BIT_) || defined(_UGL_HARDWARE_1BIT_)	GrahicsHW_SetPixel(xLoc, yLoc, g8bitForeColor);#endif}//*******************************************************************************void	setPixel(short xLoc, short yLoc, COLOR *theColor){#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_SetPixelRGB(xLoc, yLoc, theColor);#elif defined(_UGL_HARDWARE_8BIT_) || defined(_UGL_HARDWARE_1BIT_)	unsigned char	my8bitColor;		my8bitColor	=	Get8bitColorFromRGBcolor(theColor);	GrahicsHW_SetPixel(xLoc, yLoc, my8bitColor);#endif}//*******************************************************************************void	getPixel(COLOR *buffer, short x, short y){//	dispRead(buffer, x, y);}//*******************************************************************************void	line(short x1, short y1, short x2, short y2){#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_DrawLineRGB(x1, y1, x2, y2, &gRGB_ForeColor);#else	GrahicsHW_DrawLine(x1, y1, x2, y2, g8bitForeColor);#endif}//*******************************************************************************void	rect(short xLeft, short yTop, short width, short height){RECT	theRect;	if ((width > 0) && (height > 0))	{		theRect.left	=	xLeft;		theRect.right	=	xLeft + width;		theRect.top		=	yTop;		theRect.bottom	=	yTop + height;		//	fill		if (gFillEnable)		{			GrahicsHW_FillRect(&theRect, g8bitForeColor);		}		if (gStrokeEnable)		{			//*	set pen size to 1 for wire frame			GrahicsHW_DrawRect(&theRect, g8bitForeColor);		}	}}//*******************************************************************************void	quad(short x1, short y1, short x2, short y2, short x3, short y3, short x4, short y4){uint8_t		prevStroke;uint8_t		prevStrokeWeight;	if (gFillEnable)	{		//* Save the stroke state		prevStroke			=	gStrokeEnable;		prevStrokeWeight	=	gStrokeWeightVal;		//*	Disable stroke		noStroke();		triangle(x1, y1, x2, y2, x3, y3);		triangle(x2, y2, x3, y3, x4, y4);		triangle(x1, y1, x3, y3, x4, y4);		//* Restore Stroke values		gStrokeEnable		=	prevStroke;		gStrokeWeightVal	=	prevStrokeWeight;	}	if (gStrokeEnable)	{	#if defined(_UGL_HARDWARE_FULL_COLOR_)		GrahicsHW_DrawLineRGB(x1, y1, x2, y2, &gRGB_ForeColor);		GrahicsHW_DrawLineRGB(x2, y2, x3, y3, &gRGB_ForeColor);		GrahicsHW_DrawLineRGB(x3, y3, x4, y4, &gRGB_ForeColor);		GrahicsHW_DrawLineRGB(x4, y4, x1, y1, &gRGB_ForeColor);	#else		GrahicsHW_DrawLine(x1, y1, x2, y2, g8bitForeColor);		GrahicsHW_DrawLine(x2, y2, x3, y3, g8bitForeColor);		GrahicsHW_DrawLine(x3, y3, x4, y4, g8bitForeColor);		GrahicsHW_DrawLine(x4, y4, x1, y1, g8bitForeColor);	#endif	}}//*******************************************************************************void	triangle(short x1, short y1, short x2, short y2, short x3, short y3){	if (gFillEnable)	{		GrahicsHW_FillTriangle(x1, y1, x2, y2, x3, y3, g8bitForeColor);	}	//*	always draw the OUTLINE after the fill, otherwise, the outline gets overwritten	if (gStrokeEnable)	{		GrahicsHW_DrawTriangle(x1, y1, x2, y2, x3, y3, g8bitForeColor);	}}//*******************************************************************************void	ellipse(short xLoc, short yLoc, short radx, short rady){RECT	theRect;	theRect.left	=	xLoc - radx;	theRect.right	=	xLoc + radx;	theRect.top		=	yLoc - rady;	theRect.bottom	=	yLoc + rady;#if defined(_UGL_HARDWARE_FULL_COLOR_)	if (gFillEnable)	{		GrahicsHW_FillEllipseRGB(&theRect, &gRGB_BackColor);	}	if (gStrokeEnable)	{		GrahicsHW_FillEllipseRGB(&theRect, &gRGB_ForeColor);	}#else	if (gFillEnable)	{		GrahicsHW_FillEllipse(&theRect, g8bitBackColor);	}	if (gStrokeEnable)	{		GrahicsHW_DrawEllipse(&theRect, g8bitForeColor);	}#endif}//*******************************************************************************//*	angles are in radians with 0 being 3:00void	arc(short xCenter, short yCenter, short xDiameter, short yDiameter, float startAngle, float stopAngle){short		xx, yy;short		prevxx, prevyy;float	myAngle;float	xRadius, yRadius;float	stepAngle;float	myStartAngle, myStopAngle;boolean	drawSegment;	xRadius		=	xDiameter / 2;	yRadius		=	yDiameter / 2;	stepAngle	=	PI / 50;	prevxx		=	-1;	prevyy		=	-1;	if (startAngle < stopAngle)	{		myStartAngle	=	startAngle;		myStopAngle		=	stopAngle;	}	else	{		//*	reverse the order so we are going in a POSITIVE direction		myStartAngle	=	stopAngle;		myStopAngle		=	startAngle;	}	myAngle		=	myStartAngle;	if (gFillEnable)	{	uint8_t		prevStroke;	uint8_t		prevStrokeWeight;		//* Save the stroke state		prevStroke			=	gStrokeEnable;		prevStrokeWeight	=	gStrokeWeightVal;		//*	Disable stroke		noStroke();		//*	go thru and fill triangles		drawSegment	=	false;		while (myAngle <= myStopAngle)		{			xx		=	xCenter + (xRadius * cos(myAngle));			yy		=	yCenter + (yRadius * sin(myAngle));			//*	the 1st time thru we dont want to draw a line			if (drawSegment)			{				triangle(xCenter, yCenter, prevxx, prevyy, xx, yy);			}			drawSegment	=	true;			myAngle		+=	stepAngle;			prevxx		=	xx;			prevyy		=	yy;		}		//* Restore Stroke values		gStrokeEnable		=	prevStroke;		gStrokeWeightVal	=	prevStrokeWeight;	}	if (gStrokeEnable)	{		myAngle		=	myStartAngle;		drawSegment	=	false;		while (myAngle <= myStopAngle)		{			xx		=	xCenter + (xRadius * cos(myAngle));			yy		=	yCenter + (yRadius * sin(myAngle));			//*	the 1st time thru we dont want to draw a line			if (drawSegment)			{				line(prevxx, prevyy, xx, yy);			}			drawSegment	=	true;			myAngle		+=	stepAngle;			prevxx		=	xx;			prevyy		=	yy;		}	}}#pragma mark -//*********************************************************************/*Bezier CurvesBezier curves (pronounced Òbez-yeahÓ, after their inventor, a French mathematician) are wellsuited to graphics applications on the Macintosh for a number of reasons. First, theyÕresimple to describe. A curve is a function of four points. Second, the curve is efficient tocalculate. From a precomputed table, the segments of the curve can be produced using onlyfixed-point multiplication. No trig, no messy quadratics, and no inSANEity. Third, and, to some, the most important, the Bezier curve is directly supported by the PostScript curve and curveto operators, and is one of the components of PostScriptÕs outlined fonts.  The Bezier curve is also one of the principle drawing elements of Adobe Illustratorª.  (Recently, theyÕve shown up in a number of other places.)Bezier curves have some interesting properties. Unlike some other classes of curves, they can fold over on themselves. They can also be joined together to form smooth (continuous) shapes. Figure 1 shows a few Bezier curves, including two that are joined to form a smooth shape.The Gruesome DetailsThe description of Bezier curves below is going to get a bit technical. If youÕre not comfortable with the math, you can trust that the algorithm works, and skip ahead to the implementation. However, if youÕre curious about how the curves work and how to optimize their implementation, or just donÕt trust using code that you donÕt understand, read on.The Bezier curve is a parametric function of four points; two endpoints and two ÒcontrolÓ points. The curve connects the endpoints, but doesnÕt necessarily touch the control points. The general form Bezier equation, which describes each point on the curve as a function of time, is:where P1 and P4 are the endpoints, P2 and P3 are the control points, and the wnÕs are weighting functions, which blend the four points to produce the curve. (The weights are applied to the h and v components of each point independently.) The single parameter t represents time, and varies from 0 to 1. The full form of the Bezier curve is:We know that the curve touches each endpoint, so it isnÕt too surprising that at t=0 the first weighting function is 1 and all others are 0 (i.e., the initial point on the curve is the first endpoint). Likewise, at t=1, the fourth weighting function is 1 and the rest are 0. However, itÕs what happens between 0 and 1 thatÕs really interesting. A quick side-trip into calculus to take some first derivatives tells us that the second weighting function is maximized (has its greatest impact on the curve) at t=1/3, and the third weight is maximized at t=2/3. But the clever part--the bit that the graphics books donÕt bother to mention--run the curve backwards by solving the equation for 1-t, and you find that w1(t)=w4(1-t) and w2(t)=w3(1-t). As weÕll see below, this symmetry halves the effort needed to compute values for the weights.Figure 1. Some Beizer Curves and ShapesImplementing Bezier CurvesOne strategy for implementing Bezier curves is to divide the curve into a fixed number of segments and then to pre-compute the values of the weighting functions for each of the segments. The greater the number of segments, the smoother the curve. (IÕve found that 16 works well for display purposes, but 32 is better for hardcopy.) Computing any given curve becomes a simple matter of using the four points and the precomputed weights to produce the end-points of the curve segments. Fixed-point math yields reasonable accuracy, and is a hands down winner over SANE on the older (pre-Mac II) Macs, so weÕll use it.We can optimize the process a bit. The curve touches each endpoint, so we can assume weights of 0 or 1 and neednÕt compute weights for these points. Another optimization saves both time and space. By taking advantage of the symmetric nature of the Bezier equation, we can compute arrays of values for the first two of the weighting functions, and obtain values for the other two weights by indexing backwards into the arrays.Drawing the curve, given the endpoints of the segments, is the duty of QuickDraw (or of PostScript, if youÕre really hacking).The listing below shows a reasonably efficient implementation of Bezier curves in Lightspeed Cª. A few reminders about fixed-point math: an integer times a fixed-point number yields a fixed-point number, and a fixed by fixed multiplication uses a trap. The storage requirement for the algorithm, assuming 16 segments, (32 fixed-point values), is around 32*4*4, or 512 bytes. The algorithm computes all of the segments before drawing them so that the drawing can be done at full speed. (Having all of the segments around at one time can be useful for other reasons.)More Fun With CurvesGiven an implementation for Bezier curves, there are some neat things that fall out for almost free. Drawing a set of joined curves within an OpenPoly/ClosePoly or an OpenRgn/CloseRgn envelope yields an object that can be filled with a pattern. (Shades of popular illustration packages?) For that matter, lines, arcs, wedges, and Bezier curves can be joined to produce complicated shapes, such as outlined fonts. Given the direct mapping to PostScriptÕs curve and curveto operators, Bezier curves are a natural for taking better advantage of the LaserWriter.As mentioned above, Bezier curves can be joined smoothly to produce more complicated shapes (see figure 1). The catch is that the point at which two curves are joined, and the adjacent control points, must be colinear (i.e., the three points must lay on a line). If you take a close look at Adobe IllustratorÕs drawing tool, youÕll see what this means.One nonobvious use of Bezier curves is in animation. The endpoints of the segments can be used as anchor-points for redrawing an object, giving it the effect of moving smoothly along the curve. One backgammon program that IÕve seen moves the tiles along invisible Bezier curves, and the effect is very impressive. For animation, you would probably want to vary the number of segments. Fortunately, the algorithm below is easily rewritten to produce the nth segment of an m segment curve given the the end and control points.Further OptimizationsIf youÕre really tight on space or pressed for speed, there are a few things that you can do to tighten up the algorithm. A bit of code space (and a negligible amount of time) can be preserved by eliminating the setup code in favor of statically initializing the weight arrays with precomputed constant values.*///*********************************************************************//*********************************************************************//*	http://www.mactech.com/articles/mactech/Vol.05/05.01/BezierCurve///*********************************************************************//*//*	Bezier  --  Support for Bezier curves//*	Herein reside support routines for drawing Bezier curves.//*	Copyright (C) 1987, 1988 David W. Smith//*	Submitted to MacTutor for their source-disk.//*	MacTutor Magazine//*	Volume Number:		5//*	Issue Number:		1//*	Column Tag:		C Workshop//*//*	http://www.mactech.com/articles/mactech/Vol.05/05.01/BezierCurve///*********************************************************************//*	The greater the number of curve segments, the smoother the curve, //*	and the longer it takes to generate and draw.  The number below was pulled //*	out of a hat, and seems to work o.k.//*********************************************************************//*	adapted by Mark Sproul, Jan 2009 for use in the SubPGrapnics lib//*	changed to use floats instead of Fixed data types//*	the code origninally had 3 separate routines, one to setup the weights//*	one to compute the points, and one to draw the code. This used 128 bytes//*	of static memory table for the weights. In order to save memory foot//*	print, these tables are computed each time. It takes a bit longer but//*	considering the amount of memory, its a price we can afford//*********************************************************************#define	kSEGMENTS	16#define w1(s)	weight1[s]#define w2(s)	weight2[s]#define w3(s)	weight2[kSEGMENTS - s]#define w4(s)	weight1[kSEGMENTS - s]//*********************************************************************//*//*	BezierCurve  --  Draw a Bezier Curve//*	Draw a curve with the given endpoints (p1, p4), and the given //*	control points (p2, p3).//*	Note that we make no assumptions about pen or pen mode.//*//*********************************************************************void	BezierCurve(Point p1, Point p2, Point p3, Point p4){short		ss;float	tt;float	weight1[kSEGMENTS + 1];float	weight2[kSEGMENTS + 1];Point	segment[kSEGMENTS + 1];//*	debug code//	line(p1.h, p1.v, p4.h, p4.v);//	drawcircle(p2.h, p2.v, 4);//	drawcircle(p3.h, p3.v, 4);	//*********************************************************************	//*	Compute the weights for the Bezier function.	//*********************************************************************	weight1[0]	=	1.0;	weight2[0]	=	0.0;	for (ss	= 1 ; ss < kSEGMENTS ; ++ss)	{		tt			=	(1.0 * ss) / kSEGMENTS;		weight1[ss]	=	(1.0 - tt) * ((1.0 - tt) * (1.0 - tt));		weight2[ss]	=	3 * (tt * ((tt - 1.0) * (tt - 1.0)));	}	weight1[kSEGMENTS]	=	0.0;	weight2[kSEGMENTS]	=	0.0;	//*********************************************************************	//*	//*	computeSegments  --  compute segments for the Bezier curve	//*	Compute the segments along the curve.	//*	The curve touches the endpoints, so donÕt bother to compute them.	//*	//*********************************************************************	segment[0]	=	p1;	for (ss = 1 ; ss < kSEGMENTS ; ++ss)	{		segment[ss].v	=	round(w1(ss) * p1.v + w2(ss) * p2.v + w3(ss) * p3.v + w4(ss) * p4.v);		segment[ss].h	=	round(w1(ss) * p1.h + w2(ss) * p2.h + w3(ss) * p3.h + w4(ss) * p4.h);	}	segment[kSEGMENTS]	=	p4;	//*********************************************************************	//*	now do the drawing itself	//*********************************************************************	for (ss = 0 ; ss < kSEGMENTS ; ++ss)	{		if ((ss == 0) || (segment[ss].h != segment[ss - 1].h) || (segment[ss].v != segment[ss - 1].v ))		{			line(segment[ss].h, segment[ss].v, segment[ss + 1].h, segment[ss + 1].v);		}	}}//*******************************************************************************//*	Processing version//*******************************************************************************void	bezier(short x1, short y1, short cx1, short cy1, short cx2, short cy2, short x2, short y2){Point	p1, p2, p3, p4;	p1.h	=	x1;	p1.v	=	y1;	p2.h	=	cx1;	p2.v	=	cy1;	p3.h	=	cx2;	p3.v	=	cy2;	p4.h	=	x2;	p4.v	=	y2;	BezierCurve(p1, p2, p3, p4);}//*******************************************************************************void	fill(short fillColor){	gFillEnable	=	true;	setbcolor(fillColor, fillColor, fillColor);}//*******************************************************************************void	noFill(void){	gFillEnable	=	false;}//*******************************************************************************void	noStroke(void){	gStrokeEnable		=	false;	gStrokeWeightVal	=	0;}//*******************************************************************************void	strokeWeight(short newStrokeWeight){	gStrokeWeightVal	=	newStrokeWeight;}//*******************************************************************************void	stroke(short newStrokeColor){	gStrokeEnable		=	true;	if (!gStrokeWeightVal)	{		//*	only reset it if it was zero, this will maintain other settings		//*	such as a larger value		gStrokeWeightVal	=	1;	}	setfcolor(newStrokeColor, newStrokeColor, newStrokeColor);}//*******************************************************************************void	stroke(short redValue, short greenValue, short blueValue){	gStrokeEnable		=	true;	if (!gStrokeWeightVal)	{		//*	only reset it if it was zero, this will maintain other settings		//*	such as a larger value		gStrokeWeightVal	=	1;	}	setfcolor(redValue, greenValue, blueValue);}//*******************************************************************************void	setfcolor(uint8_t redValue, uint8_t greenValue, uint8_t blueValue){unsigned char	my8bitColor;	gRGB_ForeColor.red		=	redValue;	gRGB_ForeColor.green	=	greenValue;	gRGB_ForeColor.blue		=	blueValue;	my8bitColor				=	Get8bitColorFromRGBcolor(&gRGB_ForeColor);	Set8bitForeColor(my8bitColor);}//*******************************************************************************void	setbcolor(uint8_t redValue, uint8_t greenValue, uint8_t blueValue){unsigned char	my8bitColor;	gRGB_BackColor.red		=	redValue;	gRGB_BackColor.green	=	greenValue;	gRGB_BackColor.blue		=	blueValue;	my8bitColor			=	Get8bitColorFromRGBcolor(&gRGB_BackColor);//#if defined(_UGL_HARDWARE_8BIT_) || defined(_UGL_HARDWARE_1BIT_)	Set8bitBackColor(my8bitColor);//#endif}//*******************************************************************************void	text(char *textString, short xLoc, short yLoc){	GrahicsHW_DrawText(xLoc, yLoc, textString);}#endif	//	_ENABLE_PROCESSING_ROUTINES_#pragma mark -#pragma mark QuickDraw Routines#ifdef _ENABLE_QUICKDRAW_ROUTINES_//*******************************************************************************void	SetCPixel(short xLoc, short yLoc, RGBColor *theColor){#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_SetPixelRGB(xLoc, yLoc, theColor);	#elif defined(_UGL_HARDWARE_8BIT_)	unsigned char	theColorByte;	theColorByte	=	Get8bitColorFromRGBcolor(theColor);	GrahicsHW_SetPixel(xLoc, yLoc, theColorByte);#elif defined(_UGL_HARDWARE_1BIT_)int	greyValue;	greyValue	=	(theColor->red +					theColor->green +					theColor->blue) / 3;	if (greyValue > 128)	{		GrahicsHW_SetPixel(xLoc, yLoc, kCOLOR_Black);	}	else	{		GrahicsHW_SetPixel(xLoc, yLoc, kCOLOR_White);	}	#ifdef _MONOCHROME_BLACK_ON_WHITE_	//	GrahicsHW_SetPixel(xLoc, yLoc, kCOLOR_Black);	#else	//	GrahicsHW_SetPixel(xLoc, yLoc, kCOLOR_White);	#endif#endif}//*******************************************************************************void	SetCPixel16bit(short xLoc, short yLoc, unsigned short theColor){#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_SetPixelRGB16bit(xLoc, yLoc, theColor);	#elif defined(_UGL_HARDWARE_8BIT_)	unsigned char	theColorByte;	theColorByte	=	Get8bitColorFromRGBcolor(theColor);	GrahicsHW_SetPixel(xLoc, yLoc, theColorByte);#elif defined(_UGL_HARDWARE_1BIT_)	#ifdef _MONOCHROME_BLACK_ON_WHITE_		GrahicsHW_SetPixel(xLoc, yLoc, kCOLOR_Black);	#else		GrahicsHW_SetPixel(xLoc, yLoc, kCOLOR_White);	#endif#endif}//*******************************************************************************void	MoveTo(short xLoc, short yLoc){	gCurrentLocationX	=	xLoc;	gCurrentLocationY	=	yLoc;}//*******************************************************************************void	Move(short xLoc, short yLoc){	gCurrentLocationX	+=	xLoc;	gCurrentLocationY	+=	yLoc;}//*******************************************************************************void	LineTo(short xLoc, short yLoc){#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_DrawLineRGB(gCurrentLocationX, gCurrentLocationY, xLoc, yLoc, &gRGB_ForeColor);#else	GrahicsHW_DrawLine(gCurrentLocationX, gCurrentLocationY, xLoc, yLoc, g8bitForeColor);#endif	gCurrentLocationX	=	xLoc;	gCurrentLocationY	=	yLoc;}//*******************************************************************************void	Line(short xLoc, short yLoc){#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_DrawLineRGB(gCurrentLocationX, gCurrentLocationY, xLoc, yLoc, &gRGB_ForeColor);#else	GrahicsHW_DrawLine(	gCurrentLocationX,						gCurrentLocationY,						gCurrentLocationX + xLoc,						gCurrentLocationY + yLoc,						g8bitForeColor);#endif	gCurrentLocationX	+=	xLoc;	gCurrentLocationY	+=	yLoc;}//*******************************************************************************void	SetRGBcolor(RGBColor *theColor, unsigned char redValue,  unsigned char greenValue,  unsigned char blueValue){	theColor->red	=	redValue;	theColor->green	=	greenValue;	theColor->blue	=	blueValue;}//*******************************************************************************void	RGBForeColor(RGBColor *theColor){	gRGB_ForeColor		=	*theColor;//#ifdef _UGL_HARDWARE_8BIT_	g8bitForeColor	=	Get8bitColorFromRGBcolor(theColor);	GrahicsHW_Set8bitForeColor(g8bitForeColor);//#endif#ifdef _UGL_HARDWARE_1BIT_	GrahicsHW_Set8bitForeColor(g8bitForeColor);#endif}//*******************************************************************************void	RGBBackColor(RGBColor *theColor){	gRGB_BackColor	=	*theColor;	g8bitBackColor	=	Get8bitColorFromRGBcolor(theColor);#ifdef _UGL_HARDWARE_8BIT_	GrahicsHW_Set8bitBackColor(g8bitBackColor);#endif}//*******************************************************************************void	FrameRect(RECT *theRect){	GrahicsHW_DrawRect(theRect, g8bitForeColor);}//*******************************************************************************void	FillRect(RECT *theRect){	GrahicsHW_FillRect(theRect, g8bitForeColor);}//*******************************************************************************void	EraseRect(RECT *theRect){	GrahicsHW_FillRect(theRect, g8bitBackColor);}//*******************************************************************************void	FrameOval(RECT *theRect){	GrahicsHW_DrawEllipse(theRect, g8bitForeColor);}//*******************************************************************************void	FillOval(RECT *theRect){#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_FillEllipseRGB(theRect, &gRGB_ForeColor);#else	GrahicsHW_FillEllipse(theRect, g8bitForeColor);#endif}//*******************************************************************************void	EraseOval(RECT *theRect){	GrahicsHW_DrawEllipse(theRect, g8bitBackColor);}//*******************************************************************************void	FrameOvalFromCenter(short xCenter, short yCenter, short xRadius, short yRadius){RECT	ovalRect;	ovalRect.left	=	xCenter - xRadius;	ovalRect.right	=	xCenter + xRadius;		ovalRect.top	=	yCenter - yRadius;	ovalRect.bottom	=	yCenter + yRadius;	#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_DrawEllipseRGB(&ovalRect, &gRGB_ForeColor);#else	GrahicsHW_DrawEllipse(&ovalRect, g8bitForeColor);#endif}//*******************************************************************************void	FillOvalFromCenter(short xCenter, short yCenter, short xRadius, short yRadius){RECT	ovalRect;	ovalRect.left	=	xCenter - xRadius;	ovalRect.right	=	xCenter + xRadius;		ovalRect.top	=	yCenter - yRadius;	ovalRect.bottom	=	yCenter + yRadius;#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_FillEllipseRGB(&ovalRect, &gRGB_ForeColor);#else	GrahicsHW_FillEllipse(&ovalRect, g8bitForeColor);#endif}//*******************************************************************************Boolean	PtInRect(Point thePoint, const RECT *theRect){Boolean	ptIsInRect;	ptIsInRect	=	true;	if (thePoint.h < theRect->left)	{		ptIsInRect	=	false;	}	else if (thePoint.h > theRect->right)	{		ptIsInRect	=	false;	}	else if (thePoint.v < theRect->top)	{		ptIsInRect	=	false;	}	else if (thePoint.v > theRect->bottom)	{		ptIsInRect	=	false;	}	return(ptIsInRect);}//*******************************************************************************boolean	POINTinRect(POINT thePoint, const RECT *theRect){Point myNewPoint;	myNewPoint.h	=	thePoint.x;	myNewPoint.v	=	thePoint.y;	return(PtInRect(myNewPoint, theRect));}//*******************************************************************************void	InsetRect(RECT *theRect, short insetX, short insetY){	theRect->left		+=	insetX;	theRect->right		-=	insetX;	theRect->top		+=	insetY;	theRect->bottom		-=	insetY;}//*******************************************************************************void	OffsetRect(RECT *theRect, short deltaX, short deltaY){	theRect->left		+=	deltaX;	theRect->right		+=	deltaX;	theRect->top		+=	deltaY;	theRect->bottom		+=	deltaY;}//*******************************************************************************void	SetRect(RECT *theRect, short left, short top, short right, short bottom){	theRect->left	=	left;	theRect->top	=	top;	theRect->right	=	right;	theRect->bottom	=	bottom;}//*******************************************************************************void	DrawChar(short xloc, short yloc, char theChar){	if ((xloc < 0) || (xloc > gWidth))	{		return;	}	if ((yloc < 0) || (yloc > gHeight))	{		return;	}	GrahicsHW_DrawChar(xloc, yloc, theChar);}//*******************************************************************************void	DrawCString(short xloc, short yloc, char *theCstr){	if ((xloc > gWidth) || (yloc > gHeight))	{		return;	}	GrahicsHW_DrawText(xloc, yloc, theCstr);}//*******************************************************************************void	EraseScreen(void){	GrahicsHW_EraseScreen();}#endif	//	_ENABLE_QUICKDRAW_ROUTINES_#pragma mark -#pragma mark Default graphics routines#ifndef _UGL_HARDWARE_FULL_COLOR_//*******************************************************************************void	GrahicsHW_SetPixelRGB(short xLoc, short yLoc, RGBColor *theColor){unsigned char my8bitColor;	my8bitColor	=	Get8bitColorFromRGBcolor(theColor);	GrahicsHW_SetPixel(xLoc, yLoc, my8bitColor);}#endif#ifndef _HW_SUPPORTS_LINE_//*******************************************************************************//	There's definitely an easier way to do this, but for now I'll use some help from://	http://www.codeproject.com/KB/GDI/antialias.aspx#dwuln//	Edited by inthebitz//*	"Wu" refers to Xiaolin Wu's line algorithm http://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm//*******************************************************************************#if defined(_UGL_HARDWARE_FULL_COLOR_)//*******************************************************************************void	GrahicsHW_DrawLineRGB(short x1, short y1, short x2, short y2, RGBColor *theRGBcolor){unsigned short	IntensityShift;unsigned short	ErrorAdj;unsigned short	ErrorAcc;unsigned short	ErrorAccTemp;unsigned short	Weighting;unsigned short	WeightingComplementMask;short			DeltaX, DeltaY, Temp, XDir;short			NumLevels;unsigned short	IntensityBits;	if ((x1 > gWidth) && (x2 > gWidth))	{		return;	}	if ((x1 < 0) && (x2 < 0))	{		return;	}	if ((y1 > gHeight) && (y2 > gHeight))	{		return;	}	if ((y1 < 0) && (y2 < 0))	{		return;	}	NumLevels		=	2;	IntensityBits	=	2;	/* Make sure the line runs top to bottom */	if (y1 > y2)	{		Temp	=	y1;		y1		=	y2;		y2		=	Temp;		Temp	=	x1;		x1		=	x2;		x2		=	Temp;	}	//*	Draw the initial pixel, which is always exactly intersected by	//*	the line and so needs no weighting	GrahicsHW_SetPixelRGB(x1, y1, theRGBcolor);	if ((DeltaX = x2 - x1) >= 0)	{		XDir	=	1;	}	else	{		XDir	=	-1;		DeltaX	=	-DeltaX; /* make DeltaX positive */	}	//*	Special-case horizontal, vertical, and diagonal lines, which	//*	require no weighting because they go right through the center of	//*	every pixel	if ((DeltaY = y2 - y1) == 0)	{		//*	Horizontal line		while (DeltaX-- != 0)		{			x1	+=	XDir;			GrahicsHW_SetPixelRGB(x1, y1, theRGBcolor);		}		return;	}	if (DeltaX == 0)	{		//*	Vertical line		do		{			y1++;			GrahicsHW_SetPixelRGB(x1, y1, theRGBcolor);		} while (--DeltaY != 0);		return;	}	if (DeltaX == DeltaY)	{		//*	Diagonal line		do		{			x1	+=	XDir;			y1++;			GrahicsHW_SetPixelRGB(x1, y1, theRGBcolor);		} while (--DeltaY != 0);		return;	}	//*	Line is not horizontal, diagonal, or vertical	ErrorAcc	=	0;	/* initialize the line error accumulator to 0 */						/* # of bits by which to shift ErrorAcc to get intensity level */	IntensityShift	=	16 - IntensityBits;	//*	Mask used to flip all bits in an intensity weighting, producing the	//*	result (1 - intensity weighting)	WeightingComplementMask	=	NumLevels - 1;	//*	Is this an X-major or Y-major line?	if (DeltaY > DeltaX)	{		//*	Y-major line; calculate 16-bit fixed-point fractional part of a		//*	pixel that X advances each time Y advances 1 pixel, truncating the		//*	result so that we won't overrun the endpoint along the X axis		ErrorAdj	=	((unsigned long) DeltaX << 16) / (unsigned long) DeltaY;		//*	Draw all pixels other than the first and last		while (--DeltaY)		{			ErrorAccTemp	=	ErrorAcc;		//*	remember currrent accumulated error			ErrorAcc		+=	ErrorAdj;		//*	calculate error for next pixel			if (ErrorAcc <= ErrorAccTemp)			{				//*	The error accumulator turned over, so advance the X coord				x1	+=	XDir;			}			y1++;	//*	Y-major, so always advance Y			//*	The IntensityBits most significant bits of ErrorAcc give us the			//*	intensity weighting for this pixel, and the complement of the			//*	weighting for the paired pixel			Weighting	=	ErrorAcc >> IntensityShift;			//////////////////////////////////////////////////////			GrahicsHW_SetPixelRGB(x1, y1, theRGBcolor);		}		//*	Draw the final pixel, which is		//*	always exactly intersected by the line		//*	and so needs no weighting		GrahicsHW_SetPixelRGB(x2, y2, theRGBcolor);		return;	}	//*	It's an X-major line; calculate 16-bit fixed-point fractional part of a	//*	pixel that Y advances each time X advances 1 pixel, truncating the	//*	result to avoid overrunning the endpoint along the X axis	ErrorAdj	=	((unsigned long) DeltaY << 16) / (unsigned long) DeltaX;	//*	Draw all pixels other than the first and last	while (--DeltaX)	{		ErrorAccTemp	=	ErrorAcc;	//*	remember currrent accumulated error		ErrorAcc += ErrorAdj;			//*	calculate error for next pixel		if (ErrorAcc <= ErrorAccTemp)		{			//*	The error accumulator turned over, so advance the Y coord			y1++;		}		x1	+=	XDir; //*	X-major, so always advance X		//*	The IntensityBits most significant bits of ErrorAcc give us the		//*	intensity weighting for this pixel, and the complement of the		//*	weighting for the paired pixel		Weighting	=	ErrorAcc >> IntensityShift;		///////////////////////////////////////////////////		GrahicsHW_SetPixelRGB(x1, y1, theRGBcolor);	}	//*	Draw the final pixel, which is always exactly intersected by the line	//*	and so needs no weighting	GrahicsHW_SetPixelRGB(x2, y2, theRGBcolor);}#else//*******************************************************************************//	There's definitely an easier way to do this, but for now I'll use some help from://	http://www.codeproject.com/KB/GDI/antialias.aspx#dwuln//	Edited by inthebitz//*	"Wu" refers to Xiaolin Wu's line algorithm http://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm//*******************************************************************************//*******************************************************************************void	GrahicsHW_DrawLine(short x1, short y1, short x2, short y2, unsigned char the8BitColor){unsigned short	IntensityShift;unsigned short	ErrorAdj;unsigned short	ErrorAcc;unsigned short	ErrorAccTemp;unsigned short	Weighting;unsigned short	WeightingComplementMask;short			DeltaX, DeltaY, Temp, XDir;short			NumLevels;unsigned short	IntensityBits;	if ((x1 > gWidth) && (x2 > gWidth))	{		return;	}	if ((x1 < 0) && (x2 < 0))	{		return;	}	if ((y1 > gHeight) && (y2 > gHeight))	{		return;	}	if ((y1 < 0) && (y2 < 0))	{		return;	}	NumLevels		=	2;	IntensityBits	=	2;	/* Make sure the line runs top to bottom */	if (y1 > y2)	{		Temp	=	y1;		y1		=	y2;		y2		=	Temp;		Temp	=	x1;		x1		=	x2;		x2		=	Temp;	}	//*	Draw the initial pixel, which is always exactly intersected by	//*	the line and so needs no weighting	GrahicsHW_SetPixel(x1, y1, the8BitColor);	if ((DeltaX = x2 - x1) >= 0)	{		XDir	=	1;	}	else	{		XDir	=	-1;		DeltaX	=	-DeltaX; /* make DeltaX positive */	}	//*	Special-case horizontal, vertical, and diagonal lines, which	//*	require no weighting because they go right through the center of	//*	every pixel	if ((DeltaY = y2 - y1) == 0)	{		//*	Horizontal line		while (DeltaX-- != 0)		{			x1	+=	XDir;			GrahicsHW_SetPixel(x1, y1, the8BitColor);		}		return;	}	if (DeltaX == 0)	{		//*	Vertical line		do		{			y1++;			GrahicsHW_SetPixel(x1, y1, the8BitColor);		} while (--DeltaY != 0);		return;	}	if (DeltaX == DeltaY)	{		//*	Diagonal line		do		{			x1	+=	XDir;			y1++;			GrahicsHW_SetPixel(x1, y1, the8BitColor);		} while (--DeltaY != 0);		return;	}	//*	Line is not horizontal, diagonal, or vertical	ErrorAcc	=	0;	/* initialize the line error accumulator to 0 */						/* # of bits by which to shift ErrorAcc to get intensity level */	IntensityShift	=	16 - IntensityBits;	//*	Mask used to flip all bits in an intensity weighting, producing the	//*	result (1 - intensity weighting)	WeightingComplementMask	=	NumLevels - 1;	//*	Is this an X-major or Y-major line?	if (DeltaY > DeltaX)	{		//*	Y-major line; calculate 16-bit fixed-point fractional part of a		//*	pixel that X advances each time Y advances 1 pixel, truncating the		//*	result so that we won't overrun the endpoint along the X axis		ErrorAdj	=	((unsigned long) DeltaX << 16) / (unsigned long) DeltaY;		//*	Draw all pixels other than the first and last		while (--DeltaY)		{			ErrorAccTemp	=	ErrorAcc;		//*	remember currrent accumulated error			ErrorAcc		+=	ErrorAdj;		//*	calculate error for next pixel			if (ErrorAcc <= ErrorAccTemp)			{				//*	The error accumulator turned over, so advance the X coord				x1	+=	XDir;			}			y1++;	//*	Y-major, so always advance Y			//*	The IntensityBits most significant bits of ErrorAcc give us the			//*	intensity weighting for this pixel, and the complement of the			//*	weighting for the paired pixel			Weighting	=	ErrorAcc >> IntensityShift;			//////////////////////////////////////////////////////			GrahicsHW_SetPixel(x1, y1, the8BitColor);		}		//*	Draw the final pixel, which is		//*	always exactly intersected by the line		//*	and so needs no weighting		GrahicsHW_SetPixel(x2, y2, the8BitColor);		return;	}	//*	It's an X-major line; calculate 16-bit fixed-point fractional part of a	//*	pixel that Y advances each time X advances 1 pixel, truncating the	//*	result to avoid overrunning the endpoint along the X axis	ErrorAdj	=	((unsigned long) DeltaY << 16) / (unsigned long) DeltaX;	//*	Draw all pixels other than the first and last	while (--DeltaX)	{		ErrorAccTemp	=	ErrorAcc;	//*	remember currrent accumulated error		ErrorAcc += ErrorAdj;			//*	calculate error for next pixel		if (ErrorAcc <= ErrorAccTemp)		{			//*	The error accumulator turned over, so advance the Y coord			y1++;		}		x1	+=	XDir; //*	X-major, so always advance X		//*	The IntensityBits most significant bits of ErrorAcc give us the		//*	intensity weighting for this pixel, and the complement of the		//*	weighting for the paired pixel		Weighting	=	ErrorAcc >> IntensityShift;		///////////////////////////////////////////////////		GrahicsHW_SetPixel(x1, y1, the8BitColor);	}	//*	Draw the final pixel, which is always exactly intersected by the line	//*	and so needs no weighting	GrahicsHW_SetPixel(x2, y2, the8BitColor);}#endif#endif		//	_HW_SUPPORTS_LINE_#ifndef _HW_SUPPORTS_8BITCOLOR_//*******************************************************************************void	GrahicsHW_Set8bitForeColor(unsigned char the8bitColor){#ifdef _UGL_HARDWARE_1BIT_	#ifdef _MONOCHROME_BLACK_ON_WHITE_		g8bitForeColor	=	kCOLOR_Black;	#else		g8bitForeColor	=	kCOLOR_White;	#endif#else	g8bitForeColor		=	the8bitColor;#endif}//*******************************************************************************void	GrahicsHW_Set8bitBackColor(unsigned char the8bitColor){#ifdef _UGL_HARDWARE_1BIT_	#ifdef _MONOCHROME_BLACK_ON_WHITE_		g8bitBackColor	=	kCOLOR_White;	#else		g8bitBackColor	=	kCOLOR_Black;	#endif#else	g8bitBackColor		=	the8bitColor;#endif}#endif#ifndef _HW_SUPPORTS_RECT_//*******************************************************************************void	GrahicsHW_DrawRect(RECT *theRect, unsigned char the8BitColor){#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_DrawLineRGB(theRect->left,	theRect->top,		theRect->right,	theRect->top,		&gRGB_ForeColor);	GrahicsHW_DrawLineRGB(theRect->right,	theRect->top,		theRect->right,	theRect->bottom,	&gRGB_ForeColor);	GrahicsHW_DrawLineRGB(theRect->right,	theRect->bottom,	theRect->left,	theRect->bottom,	&gRGB_ForeColor);	GrahicsHW_DrawLineRGB(theRect->left,	theRect->bottom,	theRect->left,	theRect->top,		&gRGB_ForeColor);#else	GrahicsHW_DrawLine(theRect->left,	theRect->top,		theRect->right,	theRect->top,		g8bitForeColor);	GrahicsHW_DrawLine(theRect->right,	theRect->top,		theRect->right,	theRect->bottom,	g8bitForeColor);	GrahicsHW_DrawLine(theRect->right,	theRect->bottom,	theRect->left,	theRect->bottom,	g8bitForeColor);	GrahicsHW_DrawLine(theRect->left,	theRect->bottom,	theRect->left,	theRect->top,		g8bitForeColor);#endif}#endif#ifndef _HW_SUPPORTS_RECT_FILL_//*******************************************************************************void	GrahicsHW_FillRect(RECT *theRect, unsigned char the8BitColor){	//*	we have to fill the rect the hardway}#endif#ifndef _HW_SUPPORTS_ELLIPSE_#define	incx() xx++, dxt += d2xt, t += dxt#define	incy() yy--, dyt += d2yt, t += dyt#if defined(_UGL_HARDWARE_FULL_COLOR_)//*******************************************************************************void	GrahicsHW_DrawEllipseRGB(RECT *theRect, RGBColor *rgbColor){short	xx;short	yy;long	a2;long	b2;long	crit1;long	crit2;long	crit3;long	t;long	dxt;long	dyt;;long	d2xt;	long	d2yt;short		xCenter;short		yCenter;long	xRadius;long	yRadius;	xCenter	=	(theRect->left + theRect->right) / 2;	yCenter	=	(theRect->top + theRect->bottom) / 2;		xRadius	=	(theRect->right - theRect->left) / 2;	yRadius	=	(theRect->bottom - theRect->top) / 2;		xx		=	0;	yy		=	yRadius;	a2		=	(long)xRadius * xRadius;	b2		=	(long)yRadius * yRadius;	crit1	=	-(a2 / 4 + xRadius % 2 + b2);	crit2	=	-(b2 / 4 + yRadius % 2 + a2);	crit3	=	-(b2 / 4 + yRadius % 2);	t		=	-a2 * yy; 	dxt		=	2 * b2 * xx;	dyt		=	-2 * a2 * yy;	d2xt	=	2 * b2;	d2yt	=	2 * a2;//	while (yy >= 0 && xx <= xCenter)	while (yy >= 0)	{		GrahicsHW_SetPixelRGB(xCenter	+ xx, yCenter + yy, rgbColor);		if (xx != 0 || yy != 0)		{			GrahicsHW_SetPixelRGB(xCenter - xx, yCenter - yy, rgbColor);		}		if (xx != 0 && yy != 0)		{			GrahicsHW_SetPixelRGB(xCenter + xx, yCenter - yy, rgbColor);			GrahicsHW_SetPixelRGB(xCenter - xx, yCenter + yy, rgbColor);		}		if (((t + b2 * xx) <= crit1) ||	((t + a2 * yy) <= crit3))		{			incx();		}		else if ((t - a2 * yy) > crit2)		{			incy();		}		else		{			incx();			incy();		}	}}#endif//*******************************************************************************void	GrahicsHW_DrawEllipse(RECT *theRect, unsigned char the8BitColor){short	xx;short	yy;long	a2;long	b2;long	crit1;long	crit2;long	crit3;long	t;long	dxt;long	dyt;;long	d2xt;	long	d2yt;short		xCenter;short		yCenter;long	xRadius;long	yRadius;	xCenter	=	(theRect->left + theRect->right) / 2;	yCenter	=	(theRect->top + theRect->bottom) / 2;		xRadius	=	(theRect->right - theRect->left) / 2;	yRadius	=	(theRect->bottom - theRect->top) / 2;		xx		=	0;	yy		=	yRadius;	a2		=	(long)xRadius * xRadius;	b2		=	(long)yRadius * yRadius;	crit1	=	-(a2 / 4 + xRadius % 2 + b2);	crit2	=	-(b2 / 4 + yRadius % 2 + a2);	crit3	=	-(b2 / 4 + yRadius % 2);	t		=	-a2 * yy; 	dxt		=	2 * b2 * xx;	dyt		=	-2 * a2 * yy;	d2xt	=	2 * b2;	d2yt	=	2 * a2;//	while (yy >= 0 && xx <= xCenter)	while (yy >= 0)	{		GrahicsHW_SetPixel(xCenter	+ xx, yCenter + yy, the8BitColor);		if (xx != 0 || yy != 0)		{			GrahicsHW_SetPixel(xCenter - xx, yCenter - yy, the8BitColor);		}		if (xx != 0 && yy != 0)		{			GrahicsHW_SetPixel(xCenter + xx, yCenter - yy, the8BitColor);			GrahicsHW_SetPixel(xCenter - xx, yCenter + yy, the8BitColor);		}		if (((t + b2 * xx) <= crit1) ||	((t + a2 * yy) <= crit3))		{			incx();		}		else if ((t - a2 * yy) > crit2)		{			incy();		}		else		{			incx();			incy();		}	}#if defined(_DEBUG_VIA_SERIAL_) && defined(_DEBUG_CIRCLES_)	Serial.print("xx= ");	Serial.print(xx);	Serial.print(" xCenter= ");	Serial.print(xCenter);	Serial.print(" yy= ");	Serial.print(yy);	Serial.println();//	delay(1000);#endif}#endif#ifndef _HW_SUPPORTS_ELLIPSE_FILL_//*******************************************************************************void	GrahicsHW_FillEllipseRGB(RECT *theRect, RGBColor *rgbColor){short	xCenter	=	(theRect->left + theRect->right) / 2;short	yCenter	=	(theRect->top + theRect->bottom) / 2;short	xRadius	=	(theRect->right - theRect->left) / 2;short	yRadius	=	(theRect->bottom - theRect->top) / 2;int				xx		=	0;int				yy		=	yRadius;unsigned int	width	=	1;long			a2		=	(long)xRadius * xRadius;long			b2		=	(long)yRadius * yRadius;long			crit1	=	-(a2 / 4 + xRadius % 2 + b2);long			crit2	=	-(b2 / 4 + yRadius % 2 + a2);long			crit3	=	-(b2/4 + yRadius % 2);long			t		=	-a2 * yy; /* e(x+1/2,y-1/2) - (a^2+b^2)/4 */long			dxt		=	2 * b2 * xx;long			dyt		=	-2 * a2 * yy;long			d2xt	=	2 * b2;long			d2yt	=	2 * a2;	while (yy >= 0 &&  xx <= xRadius)	{		if (t + b2 * xx <= crit1 ||	 /* e(x+1,y-1/2) <= 0 */			t + a2 * yy <= crit3)		{			/* e(x+1/2,y) <= 0 */			incx();			width	+=	2;		}		else if (t - a2 * yy > crit2)		{			/* e(x+1/2,y-1) > 0 */			//dispRectangle(xCenter - x, yCenter - y, width, 1);			//dispRectangle(xCenter - xx, yCenter - yy, width, 1);			GrahicsHW_DrawLineRGB(xCenter - xx, yCenter - yy, (xCenter - xx + width), (yCenter - yy), rgbColor);			if (yy != 0)			{				//dispRectangle(xCenter- xx, yCenter + y, width, 1);				//dispRectangle(xCenter - xx, yCenter + yy, width, 1);				GrahicsHW_DrawLineRGB((xCenter - xx), (yCenter + yy), (xCenter - xx + width), (yCenter + yy), rgbColor);			}			incy();		}		else		{			//dispRectangle(xCenter - xx, yCenter - y, width, 1);			//dispRectangle(xCenter - xx, yCenter - yy, width, 1);			GrahicsHW_DrawLineRGB(xCenter - xx, yCenter - yy, (xCenter - xx + width), (yCenter - yy), rgbColor);			if (yy != 0)			{				//dispRectangle(xCenter - xx, yCenter + y, width, 1);				//dispRectangle(xCenter - xx, yCenter + yy, width, 1);				GrahicsHW_DrawLineRGB((xCenter - xx), (yCenter + yy), (xCenter - xx + width), (yCenter + yy), rgbColor);			}			incx();			incy();			width	+=	2;		}	}	if (yRadius == 0)	{		//dispRectangle(xCenter - xRadius, yCenter, 2 * xRadius + 1, 1);		//dispRectangle(xCenter - xRadius, yCenter, 2 * xRadius + 1, 1);		GrahicsHW_DrawLineRGB((xCenter - xRadius), (yCenter), (xCenter - xRadius + xRadius + 1), (yCenter), rgbColor);	}}#endif#ifndef _HW_SUPPORTS_TRIANGLE_//*******************************************************************************void	GrahicsHW_DrawTriangle(short x1, short y1, short x2, short y2, short x3, short y3, unsigned char the8BitColor){#if defined(_UGL_HARDWARE_FULL_COLOR_)	GrahicsHW_DrawLineRGB(x1, y1, x2, y2, &gRGB_ForeColor);	GrahicsHW_DrawLineRGB(x2, y2, x3, y3, &gRGB_ForeColor);	GrahicsHW_DrawLineRGB(x3, y3, x1, y1, &gRGB_ForeColor);#else	GrahicsHW_DrawLine(x1, y1, x2, y2, g8bitForeColor);	GrahicsHW_DrawLine(x2, y2, x3, y3, g8bitForeColor);	GrahicsHW_DrawLine(x3, y3, x1, y1, g8bitForeColor);#endif}#endif#ifndef _HW_SUPPORTS_TRIANGLE_FILL_//*******************************************************************************void	GrahicsHW_FillTriangle(short x1, short y1, short x2, short y2, short x3, short y3, unsigned char the8BitColor){	}#endif#ifndef _HW_SUPPORTS_TEXT_#include	"SystemFont5x7.h"//*******************************************************************************void	GrahicsHW_DrawChar(short xLoc, short yLoc, char theChar){short			charDataIndex;short				myXloc;short				myYloc;short				ii, jj;unsigned char	theBits;	if ((xLoc > gWidth) || (yLoc > gHeight))	{		return;	}	//*	we know this is a 5x7 character matrix		//*	compute the offset into the array	charDataIndex	=	6 + ((theChar - 0x20) * 5);	myXloc			=	xLoc;	myYloc			=	yLoc;		for (ii=0; ii<5; ii++)	{		//*	get the byte definition of the char	#if defined(__AVR__)		theBits	=	pgm_read_byte(System5x7 + charDataIndex + ii);	#else		theBits	=	System5x7[charDataIndex + ii];	#endif		for (jj=0; jj<7; jj++)		{			theBits	=	theBits	<<	1;						if (theBits & 0x80)			{			#if defined(_UGL_HARDWARE_FULL_COLOR_)				GrahicsHW_SetPixelRGB(myXloc + ii, myYloc - jj, &gRGB_ForeColor);			#else				GrahicsHW_SetPixel(myXloc + ii, myYloc - jj, g8bitForeColor);			#endif			}		}	}}//*******************************************************************************void	GrahicsHW_DrawText(short xLoc, short yLoc, char *textString){unsigned short	ii;	ii	=	0;	while (textString[ii] != 0)	{		GrahicsHW_DrawChar((xLoc + (ii * 7)), yLoc, textString[ii]);		ii++;	}}#endif#ifndef _HW_SUPPORTS_BUTTONS_WITH_TEXT_//*******************************************************************************void	GrahicsHW_DrawButtonWtext(short xLoc, short yLoc, char *buttonText){	}#endif#endif	//	_ENABLE_UGL_