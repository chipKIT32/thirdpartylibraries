//*******************************************************************************//*	//*	GLD T6963C Arduino drivers//*	//*	(C) by Mark Sproul//*	This code is derived from other works. Credit is given below//*	This is open source like the rest of the arduino source code//*//*	this code is derived from code from Sparkfun//*//*******************************************************************************//*******************************************************************************//*******************************************************************************//*	<MLS> is Mark Sproul msproul -at- skychariot.com//*			http://coewww.rutgers.edu/~msproul///*******************************************************************************//*	Detailed edit history//*******************************************************************************//*	Jan 28,	2010	<MLS> Started on UnivGraphicsLib//*	Feb  8,	2010	<MLS> Ordered Graphic LCD 160x128 Huge sku: LCD-08799 from sparkfun, uses T6963C//*	Feb  8,	2010	<MLS> Started on support for T6963C//*	Feb 12,	2010	<MSS> Received GLCD from Sparkfun//*******************************************************************************#include	<string.h>#include	<stdio.h>#include	<stdlib.h>#if defined(__AVR__)	#include	<avr/pgmspace.h>	#include	<avr/io.h>	#include	<avr/interrupt.h>#endif#include	"HardwareSerial.h"#include	"UnivGraphicsHW_Defs.h"#include	"UnivGraphicsLib.h"#include	"UnivGraphicsHardware.h"	//*	this is the routines that the implementer provides#ifdef _GRAPHICS_HW_GLCD_T6963C_#pragma mark -#pragma mark T6963C private routines/*	From web page	http://domoduino.tumblr.com/	 Sources t6963c	Pour ceux que a intŽresse, voici les liens vers la librairie t6963c modifiŽe É CÕest toujours la version Ôfull pinsÕ, pas encore la version I2C.	Les connections sont les suivantes	Data : 0->7 : digital pins 2->9	Ctrl : WR : analog pin 0	Ctrl : RD : analog pin 1	Ctrl : CE : analog pin 2	Ctrl : CD : analog pin 3	Ctrl : RESET : analog pin 4	Ctrl : FS : analog pin 5	http://www.mediafire.com/file/4uyyj54yo1u/GDt6963c.h	http://www.mediafire.com/file/dwj2mqztloy/GDt6963c.cpp*/#if 0	//*	analog starts at 14	#define	kWR_PIN		14		//*	WRITE			= analog 0	#define	kRD_PIN		15		//*	READ			= analog 1	#define	kCE_PIN		16		//*	CHIP ENABLE		= analog 2	#define	kCD_PIN		17		//*	COMMAND/DATA	= analog 3	//#define	kHALT_PIN		//*	not used	#define	kRST_PIN	18		//*	RESET			= analog 4	#define	kBackLightEnable	10#else	#define	kWR_PIN		0		//*	WRITE			= analog 0	#define	kRD_PIN		1		//*	READ			= analog 1	#define	kCE_PIN		2		//*	CHIP ENABLE		= analog 2	#define	kCD_PIN		3		//*	COMMAND/DATA	= analog 3	//#define	kHALT_PIN		//*	not used	#define	kRST_PIN	4		//*	RESET			= analog 4	#define	BL_EN		2	//PB2#endif//======================char	x_offset	=	0;char	y_offset	=	127;//*******************************************************************************static void T6963C_ioinit (void){	Serial.println("T6963C_ioinit");	#if 0	pinMode(kWR_PIN,	OUTPUT);	pinMode(kRD_PIN,	OUTPUT);	pinMode(kCE_PIN,	OUTPUT);	pinMode(kCD_PIN,	OUTPUT);	pinMode(kRST_PIN,	OUTPUT);	digitalWrite(kRST_PIN,	HIGH);	digitalWrite(kRD_PIN,	HIGH);	digitalWrite(kCE_PIN,	HIGH);	digitalWrite(kCD_PIN,	HIGH);	digitalWrite(kRST_PIN,	HIGH);	for (int ii=0; ii<2000; ii++)	{		digitalWrite(kRST_PIN, HIGH);		Serial.println("high");		delay(500);		digitalWrite(kRST_PIN, LOW);		Serial.println("low");		delay(500);	}#endif	Serial.println("T6963C_ioinit finished");#if 1	/*	WR	//PC0	RD	//PC1	CE	//PC2	C_D //PC3	HALT	//PC4	RST	//PC5	*/	PORTB	|=	(1<<BL_EN);			//Backlight off	DDRB	|=	(1<<BL_EN);			//set PB2 as output		//set these in the read/write functions instead of here	//DDRB	=	0b00000011; //PB0 and PB1 are outs	//DDRD	=	0b11111100; //PD2-PD7 are also outs. Ports B and D are the data bus.//	PORTC	=	((1<<kWR_PIN) | (1<<kRD_PIN) | (1<<kCE_PIN) | (1<<kCD_PIN) | (1<<HALT));	PORTC	&=	(~(1<<kRST_PIN));		//set the reset line low at power up//	DDRC	=	((1<<kWR_PIN) | (1<<kRD_PIN) | (1<<kCE_PIN) | (1<<kCD_PIN) | (1<<HALT) | (1<<RST));		//Init timer 2	//8,000,000 / 8 = 1,000,000//	TCCR2	=	(1<<CS21);			//Set Prescaler to 8. CS21=1	TCCR2A	=	(1<<CS21);			//Set Prescaler to 8. CS21=1	//TCCR2	=	((1<<CS20) | (1<<CS22) | (1<<CS22));#endif}//*******************************************************************************//Reads data or status//for data D_S = 1, for status D_S = 0//returns the value of the data bus//*******************************************************************************static char T6963C_read(char D_S){	char data1	=	0, data2	=	0;		DDRB	&=	0xFC;						//PB0 and PB1 inputs	DDRD	&=	0x02;						//everything but PD1 as input		PORTC	&=	~((1 << kRD_PIN) | (1 << kCE_PIN));	//CD high for status	if (D_S == 1) PORTC &= ~(1 << kCD_PIN);		//CD down for data		delayMicroseconds(0);		data1	=	PINB;	data1	&=	0x03;		data2	=	PIND;	data2	&=	0xFC;		data1	|=	data2;		PORTC	|=	((1 << kCD_PIN) | (1 << kRD_PIN) | (1 << kCE_PIN));	//all up		delayMicroseconds(0);		return data1;}//*******************************************************************************//delay for display timing//*******************************************************************************static void T6963C_delay(void){	char y;		for(y = 0; y < 20; y++)	{		asm volatile ("nop");			}		/*	asm volatile ("nop");	asm volatile ("nop");	asm volatile ("nop");	asm volatile ("nop");	asm volatile ("nop");	*/	}//*******************************************************************************//set data port//*******************************************************************************static void T6963C_set_data(char data){	//PORTB	//DB0 = PB0	//DB1 = PB1		PORTB	&=	0xFC;		//PORTD	//DB2 = PD2	//DB3 = PD3	//DB4 = PD4	//DB5 = PD5	//DB6 = PD6	//DB7 = PD7		PORTD	&=	0x03;		PORTB	|=	(data & 0x03);	PORTD	|=	(data & 0xFC);}//*******************************************************************************//Writes data (D_C = 1) or command (D_C = anything else)//*******************************************************************************static void T6963C_write(char D_C, char dataByte){	DDRB	|=	0x03;			//PB0 and PB1 are outs	DDRD	|=	0xFC;			//PD2-PD7 are also outs. Ports B and D are the data bus		T6963C_set_data(dataByte);		if (D_C == 1)	{		PORTC	&=	~((1 << kWR_PIN) | (1 << kCE_PIN) | (1 << kCD_PIN));	//down	}	else	{		PORTC	&=	~((1 << kWR_PIN) | (1 << kCE_PIN));				//down	}		delayMicroseconds(0);	PORTC	|=	((1 << kCD_PIN) | (1 << kWR_PIN) | (1 << kCE_PIN));		//all up	T6963C_delay();	DDRB	&=	0xFC;										//PB0 and PB1 inputs	DDRD	&=	0x02;										//everything but PD1 as input		delayMicroseconds(0);}//*******************************************************************************static void T6963C_clear_screen(void){short x;		//set address pointer to 0, start of graphics	while(!(T6963C_read(0) & 3));//read status	T6963C_write(1, 0);	while(!(T6963C_read(0) & 3));//read status	T6963C_write(1, 0);	while(!(T6963C_read(0) & 3));//read status	T6963C_write(0, 0x24);		for (x = 0; x < 0xA00; x++)	{		while(!(T6963C_read(0) & 3));//read status		T6963C_write(1, 0);		while(!(T6963C_read(0) & 3));//read status		T6963C_write(0, 0xC0);	}		x_offset	=	0;	y_offset	=	127;}//*******************************************************************************static void T6963C_pixel(char S_R, char x, char y){short	address	=	0;char	myByte	=	0;			//don't try to print something outside of our range	if (x >= gWidth) return;	if (y >= gHeight) return;		address	=	((127 - y) * 20) + (x / 8);		//set address pointer	while(!(T6963C_read(0) & 3));//read status	myByte	=	(char)(address & 0xFF);	T6963C_write(1, myByte);//20 bytes, 160/8		while(!(T6963C_read(0) & 3));//read status	myByte	=	(char)((address & 0xFF00) >> 8);	T6963C_write(1, myByte);		while(!(T6963C_read(0) & 3));//read status	T6963C_write(0, 0x24);		myByte	=	~(x % 8);	myByte	|=	0xF8;	if (S_R == 0) myByte &= 0xF7;		//set-reset bit	while(!(T6963C_read(0) & 3));//read status	T6963C_write(0, myByte);	}//*******************************************************************************static void T6963C_display_init(void){#ifdef _DEBUG_VIA_SERIAL_	Serial.println("T6963C_display_init");#endif	//set graphics home address to 0	while(!(T6963C_read(0) & 3));//read status	T6963C_write(1, 0);	while(!(T6963C_read(0) & 3));//read status	T6963C_write(1, 0);	while(!(T6963C_read(0) & 3));//read status	T6963C_write(0, 0x42);	//set graphics area	while(!(T6963C_read(0) & 3));//read status	T6963C_write(1, 20);//20 bytes, 160/8	while(!(T6963C_read(0) & 3));//read status	T6963C_write(1, 0);	while(!(T6963C_read(0) & 3));//read status	T6963C_write(0, 0x43);		//set mode	while(!(T6963C_read(0) & 3));//read status	T6963C_write(0, 0x80);//Or, with internal character generator		//set display mode	while(!(T6963C_read(0) & 3));//read status	T6963C_write(0, 0x98);//Graphics on#ifdef _DEBUG_VIA_SERIAL_	Serial.println("T6963C_display_init EXIT");#endif}#pragma mark -#pragma mark Graphics Hardware Routines//*******************************************************************************//*	returns TRUE if succesfullboolean	GrahicsHW_CheckIfPresent(void){	return(true);}//*******************************************************************************boolean	GrahicsHW_Init(void){#ifdef _DEBUG_VIA_SERIAL_	Serial.println("GrahicsHW_Init");	#if defined(__AVR_ATmega1280__)	Serial.println("__AVR_ATmega1280__");	#endif#endif	gWidth	=	kGLD_T6963C_width;	gHeight	=	kGLD_T6963C_height;			T6963C_ioinit();	//Setup IO pins and defaults	//reset the display	delayMicroseconds(1000);	PORTC	|=	(1 << kRST_PIN);		//initialize the display	T6963C_display_init();	T6963C_clear_screen();		//Backlight on	PORTB	&=	(~(1 << BL_EN));	return(true);}//*******************************************************************************void	GrahicsHW_EraseScreen(void){	T6963C_clear_screen();}//*******************************************************************************void	GrahicsHW_Reset(void){}//*******************************************************************************void	GrahicsHW_SetPixel(short xLoc, short yLoc, unsigned char theColorByte){uint8_t	pixelColor;	if ((xLoc >= gWidth) || (yLoc >= gHeight))	{		return;	}	if ((xLoc < 0) || (yLoc < 0))	{		return;	}	pixelColor	=	(theColorByte ? kCOLOR_Black : kCOLOR_White);	T6963C_pixel(xLoc, yLoc, pixelColor);}//*******************************************************************************short	GrahicsHW_GetWidth(void){	return(gWidth);}//*******************************************************************************short	GrahicsHW_GetHeight(void){	return(gHeight);}#endif	//	_GRAPHICS_HW_GLD_T6963C_